"""
Module: Document Type Rules Model for Adlibre DMS

Project: Adlibre DMS
Copyright: Adlibre Pty Ltd 2013
License: See LICENSE for license information
Author: Iurii Garmash
"""
import re
import logging

from django.db import models
from django.core.cache import get_cache
from django.contrib.auth.models import Permission
from django.contrib.contenttypes.models import ContentType

import core
from core.errors import DmsException
import dms_plugins

log = logging.getLogger('dms.doc_codes')

__all__ = ['DocumentTypeRule', 'DocumentTypeRuleManager', 'DocumentTypeRulePermission']


def get_doctypes():
    """returns a list of tuple for possible document types"""
    # Add method here to add ability to validate and write a validator for it.
    return [
        ('1', 'Default'),
        ('2', 'Credit Card'),
        ('3', 'Book'),
    ]


class DocumentTypeRule(models.Model):
    """
    Document Type Rules definition

    Sets up storage at the filesystem rules and several hooks for farther DMS interaction
    """
    doccode_type = models.CharField(choices=get_doctypes(), max_length=64, default='1')
    sequence_last = models.IntegerField(
        "Number of Documents", default=0,
        help_text="Last document stored. (Don't change unless you understand the consequences.)"
    )
    title = models.CharField("Document Type Rule Name", max_length=60)
    description = models.TextField("Description", blank=True)
    regex = models.CharField(
        "Filename Regex",
        max_length=100,
        blank=True,
        help_text="""
        Regex To validate Filaname against. <br />
        E.g.: <br />
        [a-z]{5}[0-9]{3}<br />
        Will validate documents with name like 'abcde222'<br />
        """
    )
    split_string = models.CharField(
        "Spliting Method",
        max_length=100,
        blank=True,
        help_text="""
        WARNING! Please assign a Split method for 'Default' doc type rule!. <br />
        It is responsible for 'Folder hierarchy' of files stored.<br />
        E.g.:<br />
        Document name: 'abcde222'<br />
        Spliting method:  ['abcde', '222', 'abcde222']<br />
        Folder Files Stored: /{{ doccode_path }}/abcde/222/abcde222/<br />
        Split string: <br />
        """
    )
    barcode_format = models.CharField(
        "Barcode Format",
        max_length=100,
        blank=False,
        default='%s',
        help_text="""
        Barcode format. Eg: <br />
        'ADL-%s'
        """
    )
    barcode_zfill = models.IntegerField(
        "Barcode Integer Length",
        max_length=2,
        blank=True,
        default=0,
        help_text="""
        Used to zero fill the integer portion of the autogenerated barcode.
        """
    )

    active = models.BooleanField(default=True)

    def __unicode__(self):
        return unicode(self.get_title())

    def save(self, *args, **kwargs):
        """Overriding save method to add permissions into admin

        @param args: arguments
        @param kwargs arguments
        """
        content_type, created = ContentType.objects.get_or_create(
            app_label='rule',
            model='',
            name='document type'
        )  # filtered upon usage with this 'name'!
        Permission.objects.get_or_create(
            codename=self.title,
            name='Can interact '+unicode(self.title),
            content_type=content_type
        )
        super(DocumentTypeRule, self).save(*args, **kwargs)

    def validate(self, document_name):
        """Validates DocumentTypeRule against available "document_name" string.

        @param document_name: is a name of a document code
        @return True if OK and False if not passed.
        """

        # TODO: expansion to validate document_name against "is_luhn_valid(self, cc)" for document_type:2 (credit Card)
        #print '%s Uncategorized: %s' % (self, self.uncategorized)
        regex = '^' + str(self.regex) + '$'
        if self.regex == '' and re.match(regex, document_name) and self.uncategorized:
            return True
        if not self.uncategorized and re.match(regex, document_name):
            return True
        return False

    def split(self, document_name=''):
        """Method to generate folder hierarchy to search for document depending on name.

        @param document_name: is a nplitting dcoderelevant

        Returns spliting method List:
        Usage e.g.:
        File name:  abcde222.pdf (document_name = 'abcde222')
        Spliting method:  ['abcde', '222', 'abcde222']
        In case of document_type_rule == no_rule returns current DATE
        """
        split_method = False
        if self.doccode_type == '1':
            # Default Storing Documents based on self.split_string
            if self.split_string:
                split_list = self.split_string.split(',')
                split_method = []
                for pair in split_list:
                    s, e = pair.split(':')
                    split_method.append(document_name[int(s):int(e)])
                split_method.append(document_name)

        if self.doccode_type == '2':
            split_method = [
                document_name[0:4],
                document_name[5:9],
                document_name[10:13],
                document_name[14:18],
                document_name
            ]
        if self.doccode_type == '3':
            # Split document_name as per Project Gutenberg method for 'eBook number' not, eText
            # http://www.gutenberg.org/dirs/00README.TXT
            split_method = []
            for i in range(len(document_name)):
                split_method.append(document_name[i-1:i])
            split_method.append(document_name)
        if not split_method:
            split_method = ['Split_errors', ]  # folder name for improper doccdes!!!!!
            log.error('doc_codes.models.DocumentTypeRule.split Splitting Errors exist for code: %s' % document_name)
        #print "Spliting method: ", split_method
        return split_method

    def is_luhn_valid(self, cc):
        """Method to validate Luhn algorithm based on:
        # Credit: http://en.wikipedia.org/wiki/Luhn_algorithm

        @param cc: Credit Card number
        """
        num = [int(x) for x in str(cc)]
        return sum(num[::-2] + [sum(divmod(d * 2, 10)) for d in num[-2::-2]]) % 10 == 0

    def get_id(self):
        """Returns instance PK"""
        return self.pk

    def get_title(self):
        """Returns instance title"""
        title = getattr(self, 'title', '')
        return title

    def get_directory_name(self):
        """Returns instance directory number"""
        return str(self.get_id())

    def get_last_document_number(self):
        """GET last document number for this instance"""
        return self.sequence_last

    def set_last_document_number(self, number):
        """SET last document number for this instance.

        @param number: number to be set in format int()
        """
        self.sequence_last = int(number)
        self.save()
        return self

    def allocate_barcode(self):
        """Function increments last document number for this Document Type Model by int(1)"""
        log.debug('doc_codes.models allocate_barcode. sequence_last: %s', self.sequence_last)
        self.sequence_last += 1
        self.save()
        return self._generate_document_barcode(self.sequence_last)

    def show_last_allocated_barcode(self):
        """Function shows last available Document Code used for this Document Type Rule"""
        self.sequence_last += 1
        return self._generate_document_barcode(self.sequence_last)

    def _generate_document_barcode(self, sequence):
        """Function generates next barcode in sequence.
        As soon as it is generated, it must be assumed to be used to avoid race.
        """
        log.debug("doc_codes.models Generate document barcode called. sequence: %s", sequence)
        # HACK: Ideally we shouldn't need a 'barcode_format' field, as that could be inferred from the regex. (maybe?)
        # along with the integer padding required? eg assume a fixed length integer portion of a regex is padded
        # TODO: Validate the generated code to ensure it's valid, and not invalid according to the regex.

        if len(self.barcode_format) > 0:
            n = str(sequence)
            n = n.zfill(self.barcode_zfill)
            log.debug('barcode: %s' % self.barcode_format % n)
            return self.barcode_format % n
        else:
            log.debug("False barcode")
            return False

    def get_docrule_plugin_mappings(self):
        """Returns DocumentTypeRule Mapping for this instance"""
        log.info('get_docrule_mapping for DocumentTypeRule : %s.' % self)
        mapping = dms_plugins.models.DoccodePluginMapping.objects.filter(
            doccode=str(self.pk),
            active=True)
        if mapping.count():
            mapping = mapping[0]
        else:
            raise DmsException('Rule not found', 404)
        return mapping

    @property
    def uncategorized(self):
        """Boolean function to know if a model is set as uncategorised in DMS"""
        configs = core.models.CoreConfiguration.objects.filter(uncategorized__pk__exact=self.pk)
        if configs.count():
            # this config is uncategorized
            return True
        return False


class DocumentTypeRuleManager(object):
    """Helper to handle document type rule searches and operations"""

    def __init__(self):
        """Every manager Instance has it's own document type rules set in memory (cache), not touching the DB often."""
        # Using cache to store DB objects.
        cache_docrules_for = 300  # 5 minutes (new updated docrules will be stored)
        cache = get_cache('core')
        cache_key = 'docrules_objects'
        cached_docrules = cache.get(cache_key, None)
        if not cached_docrules:
            self.docrules = DocumentTypeRule.objects.all()
            cache.set(cache_key, self.docrules, cache_docrules_for)
        else:
            self.docrules = cached_docrules

    def find_for_string(self, string):
        """Find a DocumentType that corresponds to certain string

        @param string: a string to check"""
        res = None
        for docrule in self.docrules:
            if docrule.validate(string):
                res = docrule
                break
        return res

    def get_docrules(self):
        """Get cached document types"""
        return self.docrules

    def get_docrule_by_name(self, name):
        """Returns a document type rule based on it's name

        @param name: is a name of this DocumentTypeRule"""
        docrules = self.get_docrules()
        docrule_set = docrules.filter(title=name)
        if docrule_set:
            return docrule_set[0]
        else:
            return None

    def get_docrule_by_id(self, id_):
        """
        Works without making additional requests to DB.

        (when used with instance variable)
        @param id_: Model PK
        """
        docrules = self.docrules
        docrule_instance = docrules.get(pk=id_)
        return docrule_instance


class DocumentTypeRulePermission(models.Model):
    """Proxy model for a proper admin placement. All the magic in admin.py"""
    pass
